syntax = "proto3";

// TODO: Rename to ingesterpb
package cortex;

option go_package = "client";

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "github.com/cortexproject/cortex/pkg/cortexpb/cortex.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.unmarshaler_all) = true;

service Ingester {
  rpc Push(cortexpb.WriteRequest) returns (cortexpb.WriteResponse) {};
  rpc Query(QueryRequest) returns (QueryResponse) {};
  rpc QueryStream(QueryRequest) returns (stream QueryStreamResponse) {};

  rpc LabelValues(LabelValuesRequest) returns (LabelValuesResponse) {};
  rpc LabelNames(LabelNamesRequest) returns (LabelNamesResponse) {};
  rpc UserStats(UserStatsRequest) returns (UserStatsResponse) {};
  rpc AllUserStats(UserStatsRequest) returns (UsersStatsResponse) {};
  rpc MetricsForLabelMatchers(MetricsForLabelMatchersRequest) returns (MetricsForLabelMatchersResponse) {};
  rpc MetricsMetadata(MetricsMetadataRequest) returns (MetricsMetadataResponse) {};

  // TransferChunks allows leaving ingester (client) to stream chunks directly to joining ingesters (server).
  rpc TransferChunks(stream TimeSeriesChunk) returns (TransferChunksResponse) {};
}

message ReadRequest {
  repeated QueryRequest queries = 1;

  enum ResponseType {
    // Server will return a single ReadResponse message with matched series that includes list of raw samples.
    // It's recommended to use streamed response types instead.
    //
    // Response headers:
    // Content-Type: "application/x-protobuf"
    // Content-Encoding: "snappy"
    SAMPLES = 0;
    // Server will stream a delimited ChunkedReadResponse message that contains XOR encoded chunks for a single series.
    // Each message is following varint size and fixed size bigendian uint32 for CRC32 Castagnoli checksum.
    //
    // Response headers:
    // Content-Type: "application/x-streamed-protobuf; proto=prometheus.ChunkedReadResponse"
    // Content-Encoding: ""
    STREAMED_XOR_CHUNKS = 1;
  }

  // accepted_response_types allows negotiating the content type of the response.
  //
  // Response types are taken from the list in the FIFO order. If no response type in `accepted_response_types` is
  // implemented by server, error is returned.
  // For request that do not contain `accepted_response_types` field the SAMPLES response type will be used.
  repeated ResponseType accepted_response_types = 2;
}

message ReadResponse {
  repeated QueryResponse results = 1;
}

// ChunkedReadResponse is a response when response_type equals STREAMED_XOR_CHUNKS.
// We strictly stream full series after series, optionally split by time. This means that a single frame can contain
// partition of the single series, but once a new series is started to be streamed it means that no more chunks will
// be sent for previous one. Series are returned sorted in the same way TSDB block are internally.
message ChunkedReadResponse {
  repeated TimeSeriesChunk chunked_series = 1;

  // query_index represents an index of the query from ReadRequest.queries these chunks relates to.
  int64 query_index = 2;
}

message QueryRequest {
  int64 start_timestamp_ms = 1;
  int64 end_timestamp_ms = 2;
  repeated LabelMatcher matchers = 3;
}

message QueryResponse {
  repeated cortexpb.TimeSeries timeseries = 1 [(gogoproto.nullable) = false];
}

// QueryStreamResponse contains a batch of timeseries chunks or timeseries. Only one of these series will be populated.
message QueryStreamResponse {
  repeated TimeSeriesChunk chunkseries = 1 [(gogoproto.nullable) = false];
  repeated cortexpb.TimeSeries timeseries = 2 [(gogoproto.nullable) = false];
}

message LabelValuesRequest {
  string label_name = 1;
  int64 start_timestamp_ms = 2;
  int64 end_timestamp_ms = 3;
  LabelMatchers matchers = 4;
}

message LabelValuesResponse {
  repeated string label_values = 1;
}

message LabelNamesRequest {
  int64 start_timestamp_ms = 1;
  int64 end_timestamp_ms = 2;
}

message LabelNamesResponse {
  repeated string label_names = 1;
}

message UserStatsRequest {}

message UserStatsResponse {
  double ingestion_rate = 1;
  uint64 num_series = 2;
  double api_ingestion_rate = 3;
  double rule_ingestion_rate = 4;
}

message UserIDStatsResponse {
  string user_id = 1;
  UserStatsResponse data = 2;
}

message UsersStatsResponse {
  repeated UserIDStatsResponse stats = 1;
}

message MetricsForLabelMatchersRequest {
  int64 start_timestamp_ms = 1;
  int64 end_timestamp_ms = 2;
  repeated LabelMatchers matchers_set = 3;
}

message MetricsForLabelMatchersResponse {
  repeated cortexpb.Metric metric = 1;
}

message MetricsMetadataRequest {
}

message MetricsMetadataResponse {
  repeated cortexpb.MetricMetadata metadata = 1;
}

message TimeSeriesChunk {
  string from_ingester_id = 1;
  string user_id = 2;
  repeated cortexpb.LabelPair labels = 3 [(gogoproto.nullable) = false, (gogoproto.customtype) = "github.com/cortexproject/cortex/pkg/cortexpb.LabelAdapter"];
  repeated Chunk chunks = 4 [(gogoproto.nullable) = false];
}

message Chunk {
  int64 start_timestamp_ms = 1;
  int64 end_timestamp_ms = 2;
  int32 encoding = 3;
  bytes data = 4;
}

message TransferChunksResponse {
}

message LabelMatchers {
  repeated LabelMatcher matchers = 1;
}

enum MatchType {
  EQUAL = 0;
  NOT_EQUAL = 1;
  REGEX_MATCH = 2;
  REGEX_NO_MATCH = 3;
}

message LabelMatcher {
  MatchType type = 1;
  string name = 2;
  string value = 3;
}

message TimeSeriesFile {
  string from_ingester_id = 1;
  string user_id = 2;
  string filename = 3;
  bytes data = 4;
}
