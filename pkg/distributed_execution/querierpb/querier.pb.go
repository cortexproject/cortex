// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: querier.proto

package querierpb

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	cortexpb "github.com/cortexproject/cortex/pkg/cortexpb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SeriesRequest contains parameters for series streaming
type SeriesRequest struct {
	QueryID    uint64 `protobuf:"varint,1,opt,name=queryID,proto3" json:"queryID,omitempty"`
	FragmentID uint64 `protobuf:"varint,2,opt,name=fragmentID,proto3" json:"fragmentID,omitempty"`
	Batchsize  int64  `protobuf:"varint,3,opt,name=batchsize,proto3" json:"batchsize,omitempty"`
}

func (m *SeriesRequest) Reset()      { *m = SeriesRequest{} }
func (*SeriesRequest) ProtoMessage() {}
func (*SeriesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7edfe438abd6b96f, []int{0}
}
func (m *SeriesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeriesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeriesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeriesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeriesRequest.Merge(m, src)
}
func (m *SeriesRequest) XXX_Size() int {
	return m.Size()
}
func (m *SeriesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SeriesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SeriesRequest proto.InternalMessageInfo

func (m *SeriesRequest) GetQueryID() uint64 {
	if m != nil {
		return m.QueryID
	}
	return 0
}

func (m *SeriesRequest) GetFragmentID() uint64 {
	if m != nil {
		return m.FragmentID
	}
	return 0
}

func (m *SeriesRequest) GetBatchsize() int64 {
	if m != nil {
		return m.Batchsize
	}
	return 0
}

// NextRequest contains parameters for data streaming
type NextRequest struct {
	QueryID    uint64 `protobuf:"varint,1,opt,name=queryID,proto3" json:"queryID,omitempty"`
	FragmentID uint64 `protobuf:"varint,2,opt,name=fragmentID,proto3" json:"fragmentID,omitempty"`
	Batchsize  int64  `protobuf:"varint,3,opt,name=batchsize,proto3" json:"batchsize,omitempty"`
}

func (m *NextRequest) Reset()      { *m = NextRequest{} }
func (*NextRequest) ProtoMessage() {}
func (*NextRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_7edfe438abd6b96f, []int{1}
}
func (m *NextRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextRequest.Merge(m, src)
}
func (m *NextRequest) XXX_Size() int {
	return m.Size()
}
func (m *NextRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NextRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NextRequest proto.InternalMessageInfo

func (m *NextRequest) GetQueryID() uint64 {
	if m != nil {
		return m.QueryID
	}
	return 0
}

func (m *NextRequest) GetFragmentID() uint64 {
	if m != nil {
		return m.FragmentID
	}
	return 0
}

func (m *NextRequest) GetBatchsize() int64 {
	if m != nil {
		return m.Batchsize
	}
	return 0
}

// SeriesBatch contains a collection of series metadata
type SeriesBatch struct {
	OneSeries []*OneSeries `protobuf:"bytes,1,rep,name=OneSeries,proto3" json:"OneSeries,omitempty"`
}

func (m *SeriesBatch) Reset()      { *m = SeriesBatch{} }
func (*SeriesBatch) ProtoMessage() {}
func (*SeriesBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_7edfe438abd6b96f, []int{2}
}
func (m *SeriesBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeriesBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeriesBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeriesBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeriesBatch.Merge(m, src)
}
func (m *SeriesBatch) XXX_Size() int {
	return m.Size()
}
func (m *SeriesBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_SeriesBatch.DiscardUnknown(m)
}

var xxx_messageInfo_SeriesBatch proto.InternalMessageInfo

func (m *SeriesBatch) GetOneSeries() []*OneSeries {
	if m != nil {
		return m.OneSeries
	}
	return nil
}

// OneSeries represents a single time series with its labels
// Used to describe the shape of incoming data
type OneSeries struct {
	Labels []*Label `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty"`
}

func (m *OneSeries) Reset()      { *m = OneSeries{} }
func (*OneSeries) ProtoMessage() {}
func (*OneSeries) Descriptor() ([]byte, []int) {
	return fileDescriptor_7edfe438abd6b96f, []int{3}
}
func (m *OneSeries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OneSeries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OneSeries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OneSeries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OneSeries.Merge(m, src)
}
func (m *OneSeries) XXX_Size() int {
	return m.Size()
}
func (m *OneSeries) XXX_DiscardUnknown() {
	xxx_messageInfo_OneSeries.DiscardUnknown(m)
}

var xxx_messageInfo_OneSeries proto.InternalMessageInfo

func (m *OneSeries) GetLabels() []*Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// StepVectorBatch contains a collection of step vectors
type StepVectorBatch struct {
	StepVectors []*StepVector `protobuf:"bytes,1,rep,name=step_vectors,json=stepVectors,proto3" json:"step_vectors,omitempty"`
}

func (m *StepVectorBatch) Reset()      { *m = StepVectorBatch{} }
func (*StepVectorBatch) ProtoMessage() {}
func (*StepVectorBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_7edfe438abd6b96f, []int{4}
}
func (m *StepVectorBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepVectorBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepVectorBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepVectorBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepVectorBatch.Merge(m, src)
}
func (m *StepVectorBatch) XXX_Size() int {
	return m.Size()
}
func (m *StepVectorBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_StepVectorBatch.DiscardUnknown(m)
}

var xxx_messageInfo_StepVectorBatch proto.InternalMessageInfo

func (m *StepVectorBatch) GetStepVectors() []*StepVector {
	if m != nil {
		return m.StepVectors
	}
	return nil
}

// StepVector represents data points at a specific timestamp
type StepVector struct {
	T             int64                `protobuf:"varint,1,opt,name=t,proto3" json:"t,omitempty"`
	Sample_IDs    []uint64             `protobuf:"varint,2,rep,packed,name=sample_IDs,json=sampleIDs,proto3" json:"sample_IDs,omitempty"`
	Samples       []float64            `protobuf:"fixed64,3,rep,packed,name=samples,proto3" json:"samples,omitempty"`
	Histogram_IDs []uint64             `protobuf:"varint,4,rep,packed,name=histogram_IDs,json=histogramIDs,proto3" json:"histogram_IDs,omitempty"`
	Histograms    []cortexpb.Histogram `protobuf:"bytes,5,rep,name=histograms,proto3" json:"histograms"`
}

func (m *StepVector) Reset()      { *m = StepVector{} }
func (*StepVector) ProtoMessage() {}
func (*StepVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_7edfe438abd6b96f, []int{5}
}
func (m *StepVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepVector.Merge(m, src)
}
func (m *StepVector) XXX_Size() int {
	return m.Size()
}
func (m *StepVector) XXX_DiscardUnknown() {
	xxx_messageInfo_StepVector.DiscardUnknown(m)
}

var xxx_messageInfo_StepVector proto.InternalMessageInfo

func (m *StepVector) GetT() int64 {
	if m != nil {
		return m.T
	}
	return 0
}

func (m *StepVector) GetSample_IDs() []uint64 {
	if m != nil {
		return m.Sample_IDs
	}
	return nil
}

func (m *StepVector) GetSamples() []float64 {
	if m != nil {
		return m.Samples
	}
	return nil
}

func (m *StepVector) GetHistogram_IDs() []uint64 {
	if m != nil {
		return m.Histogram_IDs
	}
	return nil
}

func (m *StepVector) GetHistograms() []cortexpb.Histogram {
	if m != nil {
		return m.Histograms
	}
	return nil
}

// Label represents a key-value pair for series metadata
type Label struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Label) Reset()      { *m = Label{} }
func (*Label) ProtoMessage() {}
func (*Label) Descriptor() ([]byte, []int) {
	return fileDescriptor_7edfe438abd6b96f, []int{6}
}
func (m *Label) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Label) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Label.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Label) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Label.Merge(m, src)
}
func (m *Label) XXX_Size() int {
	return m.Size()
}
func (m *Label) XXX_DiscardUnknown() {
	xxx_messageInfo_Label.DiscardUnknown(m)
}

var xxx_messageInfo_Label proto.InternalMessageInfo

func (m *Label) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func init() {
	proto.RegisterType((*SeriesRequest)(nil), "querierpb.SeriesRequest")
	proto.RegisterType((*NextRequest)(nil), "querierpb.NextRequest")
	proto.RegisterType((*SeriesBatch)(nil), "querierpb.SeriesBatch")
	proto.RegisterType((*OneSeries)(nil), "querierpb.OneSeries")
	proto.RegisterType((*StepVectorBatch)(nil), "querierpb.StepVectorBatch")
	proto.RegisterType((*StepVector)(nil), "querierpb.StepVector")
	proto.RegisterType((*Label)(nil), "querierpb.Label")
}

func init() { proto.RegisterFile("querier.proto", fileDescriptor_7edfe438abd6b96f) }

var fileDescriptor_7edfe438abd6b96f = []byte{
	// 509 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x53, 0x3d, 0x8f, 0xd3, 0x40,
	0x10, 0xf5, 0x9e, 0x9d, 0x9c, 0x3c, 0x49, 0x04, 0x5a, 0x02, 0xb2, 0x2c, 0x58, 0x2c, 0xd3, 0xb8,
	0x72, 0x20, 0x08, 0x89, 0x6b, 0x0e, 0x11, 0xa5, 0x20, 0x02, 0x81, 0xd8, 0x93, 0x28, 0x68, 0x4e,
	0xb6, 0xb5, 0x38, 0x81, 0x38, 0xf6, 0x79, 0x37, 0xa7, 0x83, 0x8a, 0x96, 0x8e, 0x9f, 0x41, 0xcf,
	0x9f, 0xb8, 0x32, 0xe5, 0x55, 0x88, 0x38, 0x0d, 0x65, 0x7e, 0x02, 0xf2, 0xfa, 0x53, 0x82, 0xf6,
	0xba, 0x79, 0xef, 0xcd, 0xdb, 0x59, 0x3f, 0xcf, 0xc2, 0xe0, 0x6c, 0xcd, 0xd2, 0x05, 0x4b, 0xdd,
	0x24, 0x8d, 0x45, 0x8c, 0xf5, 0x12, 0x26, 0xbe, 0x39, 0x0c, 0xe3, 0x30, 0x96, 0xec, 0x28, 0xaf,
	0x8a, 0x06, 0xf3, 0x28, 0x5c, 0x88, 0xf9, 0xda, 0x77, 0x83, 0x38, 0x1a, 0x05, 0x71, 0x2a, 0xd8,
	0x45, 0x92, 0xc6, 0x1f, 0x59, 0x20, 0x4a, 0x34, 0x4a, 0x3e, 0x85, 0x95, 0xe0, 0x97, 0x45, 0x61,
	0xb5, 0x43, 0x18, 0x9c, 0xe4, 0x87, 0x73, 0xca, 0xce, 0xd6, 0x8c, 0x0b, 0x6c, 0xc0, 0x61, 0x3e,
	0xee, 0xf3, 0x6c, 0x6a, 0x20, 0x0b, 0x39, 0x1a, 0xad, 0x20, 0x26, 0x00, 0x1f, 0x52, 0x2f, 0x8c,
	0xd8, 0x4a, 0xcc, 0xa6, 0xc6, 0x81, 0x14, 0x5b, 0x0c, 0xbe, 0x0b, 0xba, 0xef, 0x89, 0x60, 0xce,
	0x17, 0x5f, 0x98, 0xa1, 0x5a, 0xc8, 0x51, 0x69, 0x43, 0xd8, 0x0c, 0x7a, 0xaf, 0xd9, 0x85, 0xb8,
	0xee, 0x31, 0xcf, 0xa1, 0x57, 0x7c, 0xcf, 0x24, 0xa7, 0xf0, 0x18, 0xf4, 0x37, 0x2b, 0x56, 0x30,
	0x06, 0xb2, 0x54, 0xa7, 0x37, 0x1e, 0xba, 0x75, 0x9c, 0x6e, 0xad, 0xd1, 0xa6, 0xcd, 0x7e, 0xd2,
	0xf2, 0x60, 0x07, 0xba, 0x4b, 0xcf, 0x67, 0xcb, 0xca, 0x7d, 0xb3, 0xe5, 0x7e, 0x95, 0x0b, 0xb4,
	0xd4, 0xed, 0x97, 0x70, 0xe3, 0x44, 0xb0, 0xe4, 0x1d, 0x0b, 0x44, 0x9c, 0x16, 0xd3, 0x9f, 0x42,
	0x9f, 0x0b, 0x96, 0x9c, 0x9e, 0x4b, 0xae, 0x3a, 0xe2, 0x76, 0xeb, 0x88, 0xc6, 0x41, 0x7b, 0xbc,
	0xae, 0xb9, 0xfd, 0x13, 0x01, 0x34, 0x1a, 0xee, 0x03, 0x12, 0x32, 0x27, 0x95, 0x22, 0x81, 0xef,
	0x01, 0x70, 0x2f, 0x4a, 0x96, 0xec, 0x74, 0x36, 0xe5, 0xc6, 0x81, 0xa5, 0x3a, 0x1a, 0xd5, 0x0b,
	0x66, 0x36, 0xe5, 0x79, 0xb4, 0x05, 0xe0, 0x86, 0x6a, 0xa9, 0x0e, 0xa2, 0x15, 0xc4, 0x0f, 0x60,
	0x30, 0x5f, 0x70, 0x11, 0x87, 0xa9, 0x17, 0x49, 0xaf, 0x26, 0xbd, 0xfd, 0x9a, 0xcc, 0xed, 0x47,
	0x00, 0x35, 0xe6, 0x46, 0x47, 0x5e, 0xf9, 0x96, 0x5b, 0x6d, 0x8f, 0xfb, 0xa2, 0xd2, 0x26, 0xda,
	0xe5, 0xaf, 0xfb, 0x0a, 0x6d, 0x35, 0xdb, 0x8f, 0xa0, 0x23, 0x33, 0xc1, 0x18, 0xb4, 0x95, 0x17,
	0x31, 0x79, 0x65, 0x9d, 0xca, 0x1a, 0x0f, 0xa1, 0x73, 0xee, 0x2d, 0xd7, 0x4c, 0xfe, 0x52, 0x9d,
	0x16, 0x60, 0xfc, 0x0d, 0xc1, 0xe1, 0xdb, 0x22, 0x0e, 0x7c, 0x0c, 0xdd, 0x32, 0x75, 0xa3, 0x1d,
	0x51, 0x7b, 0x3d, 0xcd, 0x3b, 0xff, 0x28, 0x32, 0x6a, 0x5b, 0x79, 0x88, 0xf0, 0x31, 0x68, 0xf9,
	0x8a, 0xe1, 0x76, 0x4f, 0x6b, 0xe7, 0x4c, 0xf3, 0xbf, 0xc1, 0xd7, 0xfe, 0xc9, 0xb3, 0xcd, 0x96,
	0x28, 0x57, 0x5b, 0xa2, 0xec, 0xb7, 0x04, 0x7d, 0xcd, 0x08, 0xfa, 0x91, 0x11, 0x74, 0x99, 0x11,
	0xb4, 0xc9, 0x08, 0xfa, 0x9d, 0x11, 0xf4, 0x27, 0x23, 0xca, 0x3e, 0x23, 0xe8, 0xfb, 0x8e, 0x28,
	0x9b, 0x1d, 0x51, 0xae, 0x76, 0x44, 0x79, 0xdf, 0xbc, 0x4e, 0xbf, 0x2b, 0xdf, 0xd4, 0xe3, 0xbf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x5a, 0x7a, 0xce, 0x55, 0xc0, 0x03, 0x00, 0x00,
}

func (this *SeriesRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SeriesRequest)
	if !ok {
		that2, ok := that.(SeriesRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.QueryID != that1.QueryID {
		return false
	}
	if this.FragmentID != that1.FragmentID {
		return false
	}
	if this.Batchsize != that1.Batchsize {
		return false
	}
	return true
}
func (this *NextRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*NextRequest)
	if !ok {
		that2, ok := that.(NextRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.QueryID != that1.QueryID {
		return false
	}
	if this.FragmentID != that1.FragmentID {
		return false
	}
	if this.Batchsize != that1.Batchsize {
		return false
	}
	return true
}
func (this *SeriesBatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SeriesBatch)
	if !ok {
		that2, ok := that.(SeriesBatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.OneSeries) != len(that1.OneSeries) {
		return false
	}
	for i := range this.OneSeries {
		if !this.OneSeries[i].Equal(that1.OneSeries[i]) {
			return false
		}
	}
	return true
}
func (this *OneSeries) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OneSeries)
	if !ok {
		that2, ok := that.(OneSeries)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Labels) != len(that1.Labels) {
		return false
	}
	for i := range this.Labels {
		if !this.Labels[i].Equal(that1.Labels[i]) {
			return false
		}
	}
	return true
}
func (this *StepVectorBatch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StepVectorBatch)
	if !ok {
		that2, ok := that.(StepVectorBatch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.StepVectors) != len(that1.StepVectors) {
		return false
	}
	for i := range this.StepVectors {
		if !this.StepVectors[i].Equal(that1.StepVectors[i]) {
			return false
		}
	}
	return true
}
func (this *StepVector) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StepVector)
	if !ok {
		that2, ok := that.(StepVector)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.T != that1.T {
		return false
	}
	if len(this.Sample_IDs) != len(that1.Sample_IDs) {
		return false
	}
	for i := range this.Sample_IDs {
		if this.Sample_IDs[i] != that1.Sample_IDs[i] {
			return false
		}
	}
	if len(this.Samples) != len(that1.Samples) {
		return false
	}
	for i := range this.Samples {
		if this.Samples[i] != that1.Samples[i] {
			return false
		}
	}
	if len(this.Histogram_IDs) != len(that1.Histogram_IDs) {
		return false
	}
	for i := range this.Histogram_IDs {
		if this.Histogram_IDs[i] != that1.Histogram_IDs[i] {
			return false
		}
	}
	if len(this.Histograms) != len(that1.Histograms) {
		return false
	}
	for i := range this.Histograms {
		if !this.Histograms[i].Equal(&that1.Histograms[i]) {
			return false
		}
	}
	return true
}
func (this *Label) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Label)
	if !ok {
		that2, ok := that.(Label)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *SeriesRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&querierpb.SeriesRequest{")
	s = append(s, "QueryID: "+fmt.Sprintf("%#v", this.QueryID)+",\n")
	s = append(s, "FragmentID: "+fmt.Sprintf("%#v", this.FragmentID)+",\n")
	s = append(s, "Batchsize: "+fmt.Sprintf("%#v", this.Batchsize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *NextRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&querierpb.NextRequest{")
	s = append(s, "QueryID: "+fmt.Sprintf("%#v", this.QueryID)+",\n")
	s = append(s, "FragmentID: "+fmt.Sprintf("%#v", this.FragmentID)+",\n")
	s = append(s, "Batchsize: "+fmt.Sprintf("%#v", this.Batchsize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SeriesBatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&querierpb.SeriesBatch{")
	if this.OneSeries != nil {
		s = append(s, "OneSeries: "+fmt.Sprintf("%#v", this.OneSeries)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OneSeries) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&querierpb.OneSeries{")
	if this.Labels != nil {
		s = append(s, "Labels: "+fmt.Sprintf("%#v", this.Labels)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StepVectorBatch) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&querierpb.StepVectorBatch{")
	if this.StepVectors != nil {
		s = append(s, "StepVectors: "+fmt.Sprintf("%#v", this.StepVectors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *StepVector) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&querierpb.StepVector{")
	s = append(s, "T: "+fmt.Sprintf("%#v", this.T)+",\n")
	s = append(s, "Sample_IDs: "+fmt.Sprintf("%#v", this.Sample_IDs)+",\n")
	s = append(s, "Samples: "+fmt.Sprintf("%#v", this.Samples)+",\n")
	s = append(s, "Histogram_IDs: "+fmt.Sprintf("%#v", this.Histogram_IDs)+",\n")
	if this.Histograms != nil {
		vs := make([]*cortexpb.Histogram, len(this.Histograms))
		for i := range vs {
			vs[i] = &this.Histograms[i]
		}
		s = append(s, "Histograms: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Label) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&querierpb.Label{")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringQuerier(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QuerierClient is the client API for Querier service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QuerierClient interface {
	Series(ctx context.Context, in *SeriesRequest, opts ...grpc.CallOption) (Querier_SeriesClient, error)
	Next(ctx context.Context, in *NextRequest, opts ...grpc.CallOption) (Querier_NextClient, error)
}

type querierClient struct {
	cc *grpc.ClientConn
}

func NewQuerierClient(cc *grpc.ClientConn) QuerierClient {
	return &querierClient{cc}
}

func (c *querierClient) Series(ctx context.Context, in *SeriesRequest, opts ...grpc.CallOption) (Querier_SeriesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Querier_serviceDesc.Streams[0], "/querierpb.Querier/Series", opts...)
	if err != nil {
		return nil, err
	}
	x := &querierSeriesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Querier_SeriesClient interface {
	Recv() (*SeriesBatch, error)
	grpc.ClientStream
}

type querierSeriesClient struct {
	grpc.ClientStream
}

func (x *querierSeriesClient) Recv() (*SeriesBatch, error) {
	m := new(SeriesBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *querierClient) Next(ctx context.Context, in *NextRequest, opts ...grpc.CallOption) (Querier_NextClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Querier_serviceDesc.Streams[1], "/querierpb.Querier/Next", opts...)
	if err != nil {
		return nil, err
	}
	x := &querierNextClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Querier_NextClient interface {
	Recv() (*StepVectorBatch, error)
	grpc.ClientStream
}

type querierNextClient struct {
	grpc.ClientStream
}

func (x *querierNextClient) Recv() (*StepVectorBatch, error) {
	m := new(StepVectorBatch)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QuerierServer is the server API for Querier service.
type QuerierServer interface {
	Series(*SeriesRequest, Querier_SeriesServer) error
	Next(*NextRequest, Querier_NextServer) error
}

// UnimplementedQuerierServer can be embedded to have forward compatible implementations.
type UnimplementedQuerierServer struct {
}

func (*UnimplementedQuerierServer) Series(req *SeriesRequest, srv Querier_SeriesServer) error {
	return status.Errorf(codes.Unimplemented, "method Series not implemented")
}
func (*UnimplementedQuerierServer) Next(req *NextRequest, srv Querier_NextServer) error {
	return status.Errorf(codes.Unimplemented, "method Next not implemented")
}

func RegisterQuerierServer(s *grpc.Server, srv QuerierServer) {
	s.RegisterService(&_Querier_serviceDesc, srv)
}

func _Querier_Series_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SeriesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuerierServer).Series(m, &querierSeriesServer{stream})
}

type Querier_SeriesServer interface {
	Send(*SeriesBatch) error
	grpc.ServerStream
}

type querierSeriesServer struct {
	grpc.ServerStream
}

func (x *querierSeriesServer) Send(m *SeriesBatch) error {
	return x.ServerStream.SendMsg(m)
}

func _Querier_Next_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NextRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuerierServer).Next(m, &querierNextServer{stream})
}

type Querier_NextServer interface {
	Send(*StepVectorBatch) error
	grpc.ServerStream
}

type querierNextServer struct {
	grpc.ServerStream
}

func (x *querierNextServer) Send(m *StepVectorBatch) error {
	return x.ServerStream.SendMsg(m)
}

var _Querier_serviceDesc = grpc.ServiceDesc{
	ServiceName: "querierpb.Querier",
	HandlerType: (*QuerierServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Series",
			Handler:       _Querier_Series_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Next",
			Handler:       _Querier_Next_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "querier.proto",
}

func (m *SeriesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeriesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Batchsize != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.Batchsize))
		i--
		dAtA[i] = 0x18
	}
	if m.FragmentID != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.FragmentID))
		i--
		dAtA[i] = 0x10
	}
	if m.QueryID != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.QueryID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NextRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Batchsize != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.Batchsize))
		i--
		dAtA[i] = 0x18
	}
	if m.FragmentID != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.FragmentID))
		i--
		dAtA[i] = 0x10
	}
	if m.QueryID != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.QueryID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SeriesBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeriesBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeriesBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OneSeries) > 0 {
		for iNdEx := len(m.OneSeries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OneSeries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OneSeries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneSeries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OneSeries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StepVectorBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepVectorBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepVectorBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StepVectors) > 0 {
		for iNdEx := len(m.StepVectors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StepVectors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StepVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Histograms) > 0 {
		for iNdEx := len(m.Histograms) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Histograms[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuerier(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Histogram_IDs) > 0 {
		dAtA2 := make([]byte, len(m.Histogram_IDs)*10)
		var j1 int
		for _, num := range m.Histogram_IDs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintQuerier(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Samples) > 0 {
		for iNdEx := len(m.Samples) - 1; iNdEx >= 0; iNdEx-- {
			f3 := math.Float64bits(float64(m.Samples[iNdEx]))
			i -= 8
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f3))
		}
		i = encodeVarintQuerier(dAtA, i, uint64(len(m.Samples)*8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sample_IDs) > 0 {
		dAtA5 := make([]byte, len(m.Sample_IDs)*10)
		var j4 int
		for _, num := range m.Sample_IDs {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintQuerier(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x12
	}
	if m.T != 0 {
		i = encodeVarintQuerier(dAtA, i, uint64(m.T))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Label) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintQuerier(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintQuerier(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuerier(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuerier(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SeriesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryID != 0 {
		n += 1 + sovQuerier(uint64(m.QueryID))
	}
	if m.FragmentID != 0 {
		n += 1 + sovQuerier(uint64(m.FragmentID))
	}
	if m.Batchsize != 0 {
		n += 1 + sovQuerier(uint64(m.Batchsize))
	}
	return n
}

func (m *NextRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryID != 0 {
		n += 1 + sovQuerier(uint64(m.QueryID))
	}
	if m.FragmentID != 0 {
		n += 1 + sovQuerier(uint64(m.FragmentID))
	}
	if m.Batchsize != 0 {
		n += 1 + sovQuerier(uint64(m.Batchsize))
	}
	return n
}

func (m *SeriesBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OneSeries) > 0 {
		for _, e := range m.OneSeries {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	return n
}

func (m *OneSeries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	return n
}

func (m *StepVectorBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StepVectors) > 0 {
		for _, e := range m.StepVectors {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	return n
}

func (m *StepVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.T != 0 {
		n += 1 + sovQuerier(uint64(m.T))
	}
	if len(m.Sample_IDs) > 0 {
		l = 0
		for _, e := range m.Sample_IDs {
			l += sovQuerier(uint64(e))
		}
		n += 1 + sovQuerier(uint64(l)) + l
	}
	if len(m.Samples) > 0 {
		n += 1 + sovQuerier(uint64(len(m.Samples)*8)) + len(m.Samples)*8
	}
	if len(m.Histogram_IDs) > 0 {
		l = 0
		for _, e := range m.Histogram_IDs {
			l += sovQuerier(uint64(e))
		}
		n += 1 + sovQuerier(uint64(l)) + l
	}
	if len(m.Histograms) > 0 {
		for _, e := range m.Histograms {
			l = e.Size()
			n += 1 + l + sovQuerier(uint64(l))
		}
	}
	return n
}

func (m *Label) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovQuerier(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovQuerier(uint64(l))
	}
	return n
}

func sovQuerier(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuerier(x uint64) (n int) {
	return sovQuerier(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *SeriesRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SeriesRequest{`,
		`QueryID:` + fmt.Sprintf("%v", this.QueryID) + `,`,
		`FragmentID:` + fmt.Sprintf("%v", this.FragmentID) + `,`,
		`Batchsize:` + fmt.Sprintf("%v", this.Batchsize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NextRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NextRequest{`,
		`QueryID:` + fmt.Sprintf("%v", this.QueryID) + `,`,
		`FragmentID:` + fmt.Sprintf("%v", this.FragmentID) + `,`,
		`Batchsize:` + fmt.Sprintf("%v", this.Batchsize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SeriesBatch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOneSeries := "[]*OneSeries{"
	for _, f := range this.OneSeries {
		repeatedStringForOneSeries += strings.Replace(f.String(), "OneSeries", "OneSeries", 1) + ","
	}
	repeatedStringForOneSeries += "}"
	s := strings.Join([]string{`&SeriesBatch{`,
		`OneSeries:` + repeatedStringForOneSeries + `,`,
		`}`,
	}, "")
	return s
}
func (this *OneSeries) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForLabels := "[]*Label{"
	for _, f := range this.Labels {
		repeatedStringForLabels += strings.Replace(f.String(), "Label", "Label", 1) + ","
	}
	repeatedStringForLabels += "}"
	s := strings.Join([]string{`&OneSeries{`,
		`Labels:` + repeatedStringForLabels + `,`,
		`}`,
	}, "")
	return s
}
func (this *StepVectorBatch) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForStepVectors := "[]*StepVector{"
	for _, f := range this.StepVectors {
		repeatedStringForStepVectors += strings.Replace(f.String(), "StepVector", "StepVector", 1) + ","
	}
	repeatedStringForStepVectors += "}"
	s := strings.Join([]string{`&StepVectorBatch{`,
		`StepVectors:` + repeatedStringForStepVectors + `,`,
		`}`,
	}, "")
	return s
}
func (this *StepVector) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForHistograms := "[]Histogram{"
	for _, f := range this.Histograms {
		repeatedStringForHistograms += fmt.Sprintf("%v", f) + ","
	}
	repeatedStringForHistograms += "}"
	s := strings.Join([]string{`&StepVector{`,
		`T:` + fmt.Sprintf("%v", this.T) + `,`,
		`Sample_IDs:` + fmt.Sprintf("%v", this.Sample_IDs) + `,`,
		`Samples:` + fmt.Sprintf("%v", this.Samples) + `,`,
		`Histogram_IDs:` + fmt.Sprintf("%v", this.Histogram_IDs) + `,`,
		`Histograms:` + repeatedStringForHistograms + `,`,
		`}`,
	}, "")
	return s
}
func (this *Label) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Label{`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringQuerier(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *SeriesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryID", wireType)
			}
			m.QueryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentID", wireType)
			}
			m.FragmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batchsize", wireType)
			}
			m.Batchsize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Batchsize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryID", wireType)
			}
			m.QueryID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QueryID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FragmentID", wireType)
			}
			m.FragmentID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FragmentID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batchsize", wireType)
			}
			m.Batchsize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Batchsize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeriesBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeriesBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeriesBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneSeries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OneSeries = append(m.OneSeries, &OneSeries{})
			if err := m.OneSeries[len(m.OneSeries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneSeries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneSeries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneSeries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, &Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepVectorBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepVectorBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepVectorBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepVectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StepVectors = append(m.StepVectors, &StepVector{})
			if err := m.StepVectors[len(m.StepVectors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			m.T = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Sample_IDs = append(m.Sample_IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Sample_IDs) == 0 {
					m.Sample_IDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuerier
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Sample_IDs = append(m.Sample_IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Sample_IDs", wireType)
			}
		case 3:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Samples = append(m.Samples, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Samples) == 0 {
					m.Samples = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Samples = append(m.Samples, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Samples", wireType)
			}
		case 4:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Histogram_IDs = append(m.Histogram_IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthQuerier
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthQuerier
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Histogram_IDs) == 0 {
					m.Histogram_IDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuerier
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Histogram_IDs = append(m.Histogram_IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Histogram_IDs", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Histograms", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Histograms = append(m.Histograms, cortexpb.Histogram{})
			if err := m.Histograms[len(m.Histograms)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuerier
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuerier
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuerier(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthQuerier
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuerier(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuerier
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuerier
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuerier
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthQuerier
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowQuerier
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipQuerier(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthQuerier
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthQuerier = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuerier   = fmt.Errorf("proto: integer overflow")
)
